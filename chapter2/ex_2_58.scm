; a
(define (make-sum a1 a2) 
  (cond ((=number? a1 0) a2) 
        ((=number? a2 0) a1)
        ((and (number? a1) (number? a2)) 
         (+ a1 a2))
        (else (list a1 '+ a2))))
(define (sum? x) (and (pair? x) (eq? (cadr x) '+)))
(define (addend s) (car s))
(define (augend s) (caddr s))

(define (make-product m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (number? m1) (number? m2)) (* m1 m2))
        (else (list m1 '* m2))))
(define (product? x) (and (pair? x) (eq? (cadr x) '*)))
(define (multiplier p) (car p))
(define (multiplicand p) (caddr p))

; b
(define (drop-extra-parentheses seq) 
 (if (null? (cdr seq)) 
     (car seq) 
     seq)) 

(define (sum? x) 
  (cond ((null? (cdr x)) #f)
        ((and (pair? x) (eq? (cadr x) '+)) 
         #t)
        (else (sum? (cddr x)))))

(define (addend s)
  (define (recur x)
    (if (eq? (cadr x) '+)
      (cons (car x) '())
      (cons (car x) (cons (cadr x) 
                          (recur (cddr x))))))
  (if (eq? (cadr s) '+)
    (car s)
    (recur s)))

(define (augend s)
  (if (eq? (cadr s) '+)
    (drop-extra-parentheses (cddr s))
    (augend (cddr s))))
; make-product, product?, and multiplier are the same as in part a.
(define (multiplicand p) (drop-extra-parentheses (cddr p)))
